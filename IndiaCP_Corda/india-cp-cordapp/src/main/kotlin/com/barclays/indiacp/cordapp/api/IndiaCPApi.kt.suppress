package com.barclays.indiacp.cordapp.api

import com.barclays.indiacp.cordapp.contract.IndiaCommercialPaper
import com.barclays.indiacp.cordapp.protocol.issuer.DealEntryFlow
import com.barclays.indiacp.cordapp.protocol.issuer.IssueCPFlow
import net.corda.contracts.testing.fillWithSomeTestCash
import net.corda.core.contracts.DOLLARS
import net.corda.core.node.ServiceHub
import net.corda.core.node.services.linearHeadsOfType
import net.corda.core.utilities.Emoji
import net.corda.core.utilities.loggerFor
import javax.ws.rs.*
import javax.ws.rs.core.MediaType
import javax.ws.rs.core.Response


/*
 * This is the REST Client API for India CP Trade Operations
 *
 * Created by ritukedia on 07/01/17.
 */
@Path("indiacp")
class IndiaCPApi(val services: ServiceHub){
    val notaryName = "Controller" //todo: remove hardcoding

    data class CPReferenceAndAcceptablePrice(val cpRefId: String, val acceptablePrice: Int)
    data class CPJSONObject(val cpRefId: String, val issuer: String, val faceValue: Int, val maturityDays: Int)
    data class Cash(val amount: Int)

    private companion object {
        val logger = loggerFor<IndiaCPApi>()
    }

    @POST
    @Path("issueCP")
    @Consumes(MediaType.APPLICATION_JSON)
    fun issueCP(newCP: CPJSONObject): Response {
        try {
            val stx = services.invokeFlowAsync(IssueCPFlow::class.java, newCP).resultFuture.get()
            logger.info("CP Issued\n\nFinal transaction is:\n\n${Emoji.renderIfSupported(stx.tx)}")
            return Response.status(Response.Status.OK).build()
        } catch (ex: Throwable) {
            logger.info("Exception when creating deal: ${ex.toString()}")
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(ex.toString()).build()
        }
    }

    @POST
    @Path("issueCash")
    @Consumes(MediaType.APPLICATION_JSON)
    fun issueCash(amount: Cash): Response {
        val notary = services.networkMapCache.notaryNodes.single { it.legalIdentity.name == notaryName }.notaryIdentity
        services.fillWithSomeTestCash(amount.amount.DOLLARS,
                outputNotary = notary,
                ownedBy = services.myInfo.legalIdentity.owningKey)
        return Response.status(Response.Status.CREATED).build()
    }

    @GET
    @Path("fetchAllCP")
    @Produces(MediaType.APPLICATION_JSON)
    fun fetchAllCP(): Array<IndiaCommercialPaper.State>?  {
        try {
            return getAllCP()
        } catch (ex: Throwable) {
            logger.info("Exception when fetching ecp: ${ex.toString()}")
            return null
        }
    }

    private fun getAllCP(): Array<IndiaCommercialPaper.State>?  {
        val states = services.vaultService.linearHeadsOfType<IndiaCommercialPaper.State>()
        val indiacps = states.values.map { it.state.data }.toTypedArray()
        return indiacps
    }

    @GET
    @Path("fetchCP/{cpIssueId}")
    @Produces(MediaType.APPLICATION_JSON)
    fun fetchCP(@PathParam("cpIssueId") cpIssueId: String): Response {
        try {
            val cp = getCP(cpIssueId)

            return Response.status(Response.Status.OK).entity(cp).build()
        } catch (ex: Throwable) {
            logger.info("Exception when fetching ecp: ${ex.toString()}")
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(ex.toString()).build()
        }
    }

    private fun getCP(ref: String): IndiaCommercialPaper.State? {
        val states = services.vaultService.linearHeadsOfType<IndiaCommercialPaper.State>().filterValues { it.state.data.ref == ref }
        return if (states.isEmpty()) null else {
            val deals = states.values.map { it.state.data }
            return if (deals.isEmpty()) null else deals[0]
        }
    }

    @POST
    @Path("enterDeal/{investor}")
    @Consumes(MediaType.APPLICATION_JSON)
    fun enterTrade(cp : CPReferenceAndAcceptablePrice, @PathParam("investor") investorName: String): Response? {
        try {
            if (investorName != null) {
                val investor = services.identityService.partyFromName(investorName)
                val stx = services.invokeFlowAsync(DealEntryFlow::class.java, cp.cpRefId, investor).resultFuture.get()
//                val stx = rpc.startFlow(::DealEntryFlow, cp.cpRefId, investorName).returnValue.toBlocking().first()
                logger.info("CP Deal Finalized\n\nFinal transaction is:\n\n${Emoji.renderIfSupported(stx.tx)}")
                return Response.status(Response.Status.OK).build()
            } else {
                return Response.status(Response.Status.BAD_REQUEST).entity("Invalid Investor reference").build()
            }
        } catch (ex: Throwable) {
            logger.info("Exception when fetching ecp: ${ex.toString()}")
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(ex.toString()).build()
        }
    }
}
